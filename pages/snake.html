<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <title>SNAKE RESPONSIVE</title>
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <style>
      * {
        box-sizing: border-box;
        /* Emp√™che le zoom tactile et le surlignage au tap */
        -webkit-tap-highlight-color: transparent;
        touch-action: none;
      }

      body {
        margin: 0;
        height: 100vh; /* Utilise toute la hauteur */
        width: 100vw;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        background: radial-gradient(
          circle at top,
          #1a1a1a 0,
          #000000 55%,
          #000000 100%
        );
        color: #ffffff;
        font-family: "Roboto", system-ui, -apple-system, sans-serif;
        overflow: hidden; /* Emp√™che le scroll si le canvas est un peu grand */
      }

      /* En-t√™te (Titre + Score) */
      header {
        flex: 0 0 auto;
        text-align: center;
        margin-bottom: 10px;
        z-index: 10;
      }

      h1 {
        margin: 0;
        font-size: 2rem;
        letter-spacing: 2px;
        text-transform: uppercase;
        text-shadow: 0 0 10px rgba(61, 169, 252, 0.7);
        color: #ffffff;
      }

      #score {
        font-size: 1.2rem;
        text-shadow: 0 0 6px rgba(61, 169, 252, 0.6);
        color: #e0e0e0;
        margin-top: 5px;
      }

      /* Conteneur du jeu */
      .game-wrapper {
        position: relative;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 5px;
        border-radius: 12px;
        background: linear-gradient(145deg, #1a1a1a, #000000);
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.9);
      }

      canvas {
        border-radius: 8px;
        border: 2px solid #333;
        background: #000000;
        box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
        /* Le canvas sera dimensionn√© par le JS, pas par CSS width/height */
        display: block;
      }

      #message {
        flex: 0 0 auto;
        margin-top: 10px;
        font-size: 14px;
        opacity: 0.8;
        text-align: center;
        min-height: 1.5em;
        color: #bbb;
        padding: 0 10px;
      }

      /* Animation Game Over */
      @keyframes gameover-bounce {
        0%,
        100% {
          transform: translate(-50%, -50%) scale(1);
        }
        50% {
          transform: translate(-50%, -52%) scale(1.05);
        }
      }

      #gameover-img {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        max-width: 60%;
        max-height: 60%;
        display: none;
        pointer-events: none;
        filter: drop-shadow(0 0 20px rgba(0, 0, 0, 1));
        animation: gameover-bounce 1.5s ease-in-out infinite;
        z-index: 20;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>SNAKE</h1>
      <div id="score">Score : 0</div>
    </header>

    <div class="game-wrapper">
      <canvas id="game"></canvas>
      <img id="gameover-img" src="../img/SNLN.png" alt="Game Over" />
    </div>

    <div id="message"></div>

    <script>
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");
      const scoreEl = document.getElementById("score");
      const messageEl = document.getElementById("message");
      const gameoverImg = document.getElementById("gameover-img");

      const tailleCase = 20; // Taille d'une cellule de la grille
      const vitesseInitiale = 150;

      // Variables de dimensionnement (calcul√©es dynamiquement)
      let nbCasesX;
      let nbCasesY;

      let vitesse = vitesseInitiale;
      let snake;
      let direction;
      let nourriture;
      let score;
      let gameOver = false;
      let loopId = null;
      let started = false;

      // ---------- GESTION DU RESPONSIVE ----------

      function resizeCanvas() {
        // 1. Calculer l'espace disponible (fen√™tre - marges header/footer)
        // On retire environ 120px pour le titre, le score et les marges
        let maxWidth = window.innerWidth - 20;
        let maxHeight = window.innerHeight - 140;

        // On limite la taille maximale sur grand √©cran pour que le jeu reste jouable
        if (maxWidth > 600) maxWidth = 600;
        if (maxHeight > 600) maxHeight = 600;

        // 2. Ajuster pour que ce soit un multiple de "tailleCase" (20px)
        // Cela √©vite les cases coup√©es ou floues
        const width = Math.floor(maxWidth / tailleCase) * tailleCase;
        const height = Math.floor(maxHeight / tailleCase) * tailleCase;

        // 3. Appliquer les dimensions
        canvas.width = width;
        canvas.height = height;

        // 4. Mettre √† jour le nombre de cases
        nbCasesX = width / tailleCase;
        nbCasesY = height / tailleCase;

        // Si le jeu n'est pas lanc√©, on redessine l'√©cran d'accueil
        if (!started && !gameOver) {
          dessiner();
        }
      }

      // Appeler le redimensionnement au chargement et si on tourne l'√©cran
      window.addEventListener("resize", resizeCanvas);
      resizeCanvas(); // Appel initial

      // ---------- LOGIQUE DU JEU ----------

      function initJeu() {
        // On place le serpent au centre
        const startX = Math.floor(nbCasesX / 2);
        const startY = Math.floor(nbCasesY / 2);

        snake = [
          { x: startX, y: startY },
          { x: startX - 1, y: startY },
          { x: startX - 2, y: startY },
        ];

        direction = { x: 1, y: 0 };
        score = 0;
        vitesse = vitesseInitiale;
        gameOver = false;
        scoreEl.textContent = "Score : " + score;
        gameoverImg.style.display = "none";

        genererNourriture();

        if (loopId !== null) clearInterval(loopId);
        loopId = setInterval(gameLoop, vitesse);
      }

      function genererNourriture() {
        let nouvellePos;
        let collision;

        // Boucle pour √©viter de placer la nourriture sur le serpent
        do {
          collision = false;
          nouvellePos = {
            x: Math.floor(Math.random() * nbCasesX),
            y: Math.floor(Math.random() * nbCasesY),
          };
          for (let segment of snake) {
            if (segment.x === nouvellePos.x && segment.y === nouvellePos.y) {
              collision = true;
              break;
            }
          }
        } while (collision);

        nourriture = nouvellePos;
      }

      function dessinerFond() {
        ctx.fillStyle = "#000000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }

      function dessinerNourriture() {
        const emojis = ["üíª", "üñ•Ô∏è"];
        const emoji = emojis[(nourriture.x + nourriture.y) % emojis.length];

        const baseX = nourriture.x * tailleCase;
        const baseY = nourriture.y * tailleCase;

        ctx.font = "18px sans-serif";
        ctx.textBaseline = "top";
        // Petit ajustement pour centrer l'emoji
        ctx.fillText(emoji, baseX + 1, baseY + 2);
      }

      function dessinerSnake() {
        for (let i = 0; i < snake.length; i++) {
          const segment = snake[i];
          const px = segment.x * tailleCase;
          const py = segment.y * tailleCase;

          if (i === 0) {
            // T√™te
            ctx.fillStyle = "#3da9fc";
            ctx.fillRect(px, py, tailleCase, tailleCase);
            // Yeux
            ctx.fillStyle = "#000000";
            // Ajustement simple des yeux selon la direction (bonus visuel)
            ctx.fillRect(px + 4, py + 4, 4, 4);
            ctx.fillRect(px + 12, py + 4, 4, 4);
          } else {
            // Corps
            ctx.fillStyle = "#3da9fc";
            // Un peu plus petit pour effet "segments"
            ctx.fillRect(px + 1, py + 1, tailleCase - 2, tailleCase - 2);
          }
        }
      }

      function dessiner() {
        dessinerFond();

        if (!started) {
          // √âCRAN D'ACCUEIL
          ctx.save();
          ctx.fillStyle = "rgba(0,0,0,0.5)";
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          ctx.textAlign = "center";

          // Titre au centre
          ctx.font = "bold 30px sans-serif";
          ctx.fillStyle = "#3da9fc";
          ctx.fillText("SNAKE", canvas.width / 2, canvas.height / 2 - 20);

          ctx.font = "16px sans-serif";
          ctx.fillStyle = "#ffffff";
          ctx.fillText(
            "Touchez pour d√©marrer",
            canvas.width / 2,
            canvas.height / 2 + 20
          );
          ctx.restore();
          return;
        }

        dessinerNourriture();
        dessinerSnake();

        if (gameOver) {
          // Fond sombre pour Game Over
          ctx.save();
          ctx.fillStyle = "rgba(0,0,0,0.7)";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.restore();
        }
      }

      function update() {
        if (gameOver || !started) return;

        const head = {
          x: snake[0].x + direction.x,
          y: snake[0].y + direction.y,
        };

        // Collision murs (Note l'utilisation de nbCasesX et nbCasesY)
        if (
          head.x < 0 ||
          head.x >= nbCasesX ||
          head.y < 0 ||
          head.y >= nbCasesY
        ) {
          handleGameOver();
          return;
        }

        // Collision avec soi-m√™me
        for (let segment of snake) {
          if (segment.x === head.x && segment.y === head.y) {
            handleGameOver();
            return;
          }
        }

        snake.unshift(head);

        // Manger
        if (head.x === nourriture.x && head.y === nourriture.y) {
          score++;
          scoreEl.textContent = "Score : " + score;

          // Acc√©l√©ration
          if (score % 5 === 0 && vitesse > 50) {
            vitesse -= 10;
            clearInterval(loopId);
            loopId = setInterval(gameLoop, vitesse);
          }
          genererNourriture();
        } else {
          snake.pop();
        }
      }

      function handleGameOver() {
        gameOver = true;
        messageEl.textContent = "Touchez pour rejouer";
        // Affiche l'image en CSS
        gameoverImg.style.display = "block";
      }

      function gameLoop() {
        update();
        dessiner();
      }

      function startGame() {
        started = true;
        gameOver = false;
        messageEl.textContent = "";
        gameoverImg.style.display = "none";
        initJeu();
      }

      // ---------- ENTR√âES (CLAVIER + TACTILE) ----------

      // Clavier
      document.addEventListener("keydown", (e) => {
        // Emp√™che le d√©filement de la page avec les fl√®ches
        if (
          ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].indexOf(e.code) >
          -1
        ) {
          e.preventDefault();
        }

        if (e.key === "Enter" || e.code === "Space") {
          if (!started || gameOver) {
            startGame();
            return;
          }
        }

        if (!started || gameOver) return;

        switch (e.key) {
          case "ArrowUp":
            if (direction.y === 0) direction = { x: 0, y: -1 };
            break;
          case "ArrowDown":
            if (direction.y === 0) direction = { x: 0, y: 1 };
            break;
          case "ArrowLeft":
            if (direction.x === 0) direction = { x: -1, y: 0 };
            break;
          case "ArrowRight":
            if (direction.x === 0) direction = { x: 1, y: 0 };
            break;
        }
      });

      // Tactile (Swipe)
      let startX = null;
      let startY = null;
      let isSwiping = false;

      // On √©coute sur le body pour capturer le swipe m√™me si on sort un peu du canvas
      document.body.addEventListener(
        "touchstart",
        (e) => {
          const t = e.touches[0];
          startX = t.clientX;
          startY = t.clientY;
          isSwiping = false;
        },
        { passive: false }
      );

      document.body.addEventListener(
        "touchmove",
        (e) => {
          // Emp√™che le pull-to-refresh
          if (started && !gameOver) e.preventDefault();

          if (startX === null || startY === null) return;

          const t = e.touches[0];
          const dx = t.clientX - startX;
          const dy = t.clientY - startY;

          // Seuil minimum pour consid√©rer que c'est un swipe
          if (Math.abs(dx) > 20 || Math.abs(dy) > 20) {
            isSwiping = true;
            if (!started || gameOver) return;

            if (Math.abs(dx) > Math.abs(dy)) {
              // Horizontal
              if (dx > 0 && direction.x === 0) direction = { x: 1, y: 0 };
              else if (dx < 0 && direction.x === 0) direction = { x: -1, y: 0 };
            } else {
              // Vertical
              if (dy > 0 && direction.y === 0) direction = { x: 0, y: 1 };
              else if (dy < 0 && direction.y === 0) direction = { x: 0, y: -1 };
            }

            // R√©initialise pour permettre des virages rapides sans lever le doigt
            startX = t.clientX;
            startY = t.clientY;
          }
        },
        { passive: false }
      );

      document.body.addEventListener("touchend", () => {
        // Si ce n'√©tait pas un swipe (juste un tap)
        if (!isSwiping) {
          if (!started || gameOver) {
            startGame();
          }
        }
        startX = null;
        startY = null;
        isSwiping = false;
      });

      // Clic souris pour d√©marrer sur PC
      canvas.addEventListener("click", () => {
        if (!started || gameOver) {
          startGame();
        }
      });

      // Init visuelle
      messageEl.textContent = "Glissez pour jouer / Tapez pour d√©marrer";
      // Le premier dessin se fera apr√®s le resizeCanvas
    </script>
  </body>
</html>
